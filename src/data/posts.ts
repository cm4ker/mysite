export interface MicroblogPost {
  id: number;
  date: string;
  title: string;
  preview: string;
  content: string;
  tags: string[];
}

export const posts: MicroblogPost[] = [
  {
    id: 1,
    date: '2025-10-28',
    title: 'Новые возможности .NET 9',
    preview: 'Вышел .NET 9 с множеством улучшений производительности и новых функций...',
    content: `Вышел .NET 9 с множеством улучшений производительности и новых функций.
    
Основные изменения:
- Значительное улучшение производительности JIT-компилятора
- Новые возможности для работы с async/await
- Улучшенная поддержка AI и Machine Learning
- Расширенные возможности для работы с облачными сервисами

Особенно впечатляют улучшения в области производительности. Некоторые операции стали работать до 40% быстрее по сравнению с .NET 8.

Новый синтаксис для работы с коллекциями делает код более читаемым и лаконичным. Например, теперь можно использовать collection expressions для создания массивов и списков.

Также добавлена нативная поддержка векторных операций, что открывает новые возможности для AI-приложений.`,
    tags: ['.NET', 'C#', 'Performance']
  },
  {
    id: 2,
    date: '2025-10-25',
    title: 'React Server Components: мой опыт',
    preview: 'Поделюсь своим опытом использования React Server Components в production...',
    content: `Поделюсь своим опытом использования React Server Components в production проекте.

После нескольких месяцев работы с RSC могу сказать, что это действительно меняет подход к разработке React-приложений.

Преимущества:
- Значительное сокращение размера бандла на клиенте
- Улучшенная производительность при первоначальной загрузке
- Упрощенный доступ к серверным ресурсам
- Лучшая SEO-оптимизация

Недостатки:
- Крутая кривая обучения для команды
- Необходимость пересмотра архитектуры приложения
- Ограничения в использовании некоторых библиотек

Рекомендую начать с небольших проектов и постепенно расширять использование RSC. Важно понимать различия между серверными и клиентскими компонентами.`,
    tags: ['React', 'JavaScript', 'Web']
  },
  {
    id: 3,
    date: '2025-10-20',
    title: 'TypeScript 5.3: что нового?',
    preview: 'Краткий обзор новых возможностей TypeScript 5.3...',
    content: `Краткий обзор новых возможностей TypeScript 5.3 и почему стоит обновиться.

Ключевые нововведения:

1. Import Attributes
Новый синтаксис для указания атрибутов импорта, особенно полезно для JSON модулей.

2. Улучшенная работа с типами
Более точный type narrowing и улучшенная проверка типов в условных выражениях.

3. Оптимизация производительности
Компиляция стала быстрее на 15-20% для больших проектов.

4. Resolution Mode для Import Types
Новая возможность явно указывать режим разрешения для import types.

5. Улучшенная поддержка JSX
Более гибкая настройка и лучшая интеграция с современными фреймворками.

Миграция прошла гладко, не обнаружил breaking changes в наших проектах.`,
    tags: ['TypeScript', 'JavaScript']
  },
  {
    id: 4,
    date: '2025-10-15',
    title: 'Микросервисы на .NET: lessons learned',
    preview: 'Год работы с микросервисной архитектурой на .NET. Что получилось, а что нет...',
    content: `Год работы с микросервисной архитектурой на .NET. Что получилось, а что нет.

Прошел год с момента перехода нашего монолита на микросервисную архитектуру. Время подвести итоги.

Что сработало хорошо:
- Независимое развертывание сервисов
- Масштабирование отдельных компонентов
- Возможность использовать разные технологии для разных задач
- Улучшенная отказоустойчивость

Проблемы, с которыми столкнулись:
- Сложность отладки распределенных систем
- Overhead на inter-service communication
- Необходимость в robust мониторинге и логировании
- Управление транзакциями в распределенной среде

Инструменты, которые помогли:
- Docker и Kubernetes для оркестрации
- RabbitMQ для асинхронного обмена сообщениями
- ELK stack для централизованного логирования
- Prometheus и Grafana для мониторинга

Совет: не стоит переходить на микросервисы только потому что это модно. Убедитесь, что ваш проект действительно требует такой архитектуры.`,
    tags: ['.NET', 'Microservices', 'Architecture']
  },
  {
    id: 5,
    date: '2025-10-10',
    title: 'AI в повседневной разработке',
    preview: 'Как я использую AI-инструменты для ускорения разработки...',
    content: `Как я использую AI-инструменты для ускорения разработки и повышения продуктивности.

AI уже не просто хайп, а реальный инструмент в руках разработчика.

Мои основные use-cases:

1. GitHub Copilot
- Автодополнение кода
- Генерация тестов
- Написание документации

2. ChatGPT/Claude
- Объяснение сложного кода
- Brainstorming архитектурных решений
- Code review и поиск потенциальных багов

3. AI-powered поиск
- Быстрый поиск решений
- Анализ stack traces

Результаты:
- Увеличение скорости разработки на ~30%
- Меньше времени на рутинные задачи
- Больше времени на решение сложных проблем

Важно: AI - это помощник, а не замена. Критическое мышление и понимание кода остаются ключевыми.`,
    tags: ['AI', 'Productivity', 'Tools']
  },
  {
    id: 6,
    date: '2025-10-05',
    title: 'PostgreSQL vs MongoDB: когда и что выбрать',
    preview: 'Практический опыт работы с обеими СУБД...',
    content: `Практический опыт работы с обеими СУБД и рекомендации по выбору.

За последние годы работал с обеими базами данных в production. Вот мои наблюдения.

PostgreSQL - выбирайте когда:
- Нужны ACID-гарантии
- Сложные реляционные связи
- Важна целостность данных
- Нужны сложные JOIN'ы и транзакции
- Работа с финансовыми данными

MongoDB - выбирайте когда:
- Гибкая схема данных
- Высокая скорость записи
- Горизонтальное масштабирование
- Работа с неструктурированными данными
- Прототипирование и быстрая итерация

Мой выбор для новых проектов:
- PostgreSQL как основная БД для критичных данных
- MongoDB для логов, аналитики, кеширования

PostgreSQL с JSONB дает лучшее из обоих миров - надежность реляционной БД с гибкостью документо-ориентированной.

Не верьте мифам про "PostgreSQL медленный" или "MongoDB ненадежный". При правильной настройке обе БД работают отлично.`,
    tags: ['PostgreSQL', 'MongoDB', 'Database']
  },
  {
    id: 7,
    date: '2025-10-01',
    title: 'Docker best practices 2025',
    preview: 'Актуальные практики работы с Docker в 2025 году...',
    content: `Актуальные практики работы с Docker в 2025 году, которые помогут создавать эффективные образы.

1. Multi-stage builds
Обязательно используйте многоэтапные сборки для уменьшения размера финального образа.

2. .dockerignore
Не забывайте про .dockerignore - это существенно ускоряет сборку.

3. Кеширование слоев
Располагайте команды от наименее изменяемых к наиболее изменяемым.

4. Безопасность
- Не запускайте от root
- Используйте официальные базовые образы
- Регулярно обновляйте зависимости
- Сканируйте образы на уязвимости

5. Размер образа
- Используйте alpine образы где возможно
- Очищайте кеш пакетных менеджеров
- Удаляйте ненужные файлы в том же слое

6. BuildKit
Включите BuildKit для более быстрой сборки и расширенных возможностей.

Пример хорошего Dockerfile в комментариях ниже.`,
    tags: ['Docker', 'DevOps', 'Best Practices']
  }
];
